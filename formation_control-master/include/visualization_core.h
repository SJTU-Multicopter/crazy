/*  Copyright (C) 2015 Alessandro Tondo
 *  email: tondo.codes+ros <at> gmail.com
 *
 *  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 *  License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any
 *  later version.
 *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 *  details.
 *  You should have received a copy of the GNU General Public License along with this program.
 *  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef GUARD_VISUALIZATION_CORE_H
#define GUARD_VISUALIZATION_CORE_H

#include "commons.h"
// default values for ROS params (if not specified by the user)
#define DEFAULT_MARKER_DIST_MIN 0
#define DEFAULT_MARKER_DIST_MAX 0.5
#define DEFAULT_MARKER_STEER_MIN -0.52
#define DEFAULT_MARKER_STEER_MAX 0.52

/*  This class purpose is to provide a ROS interface (using rviz) which lets to visualize and guide a swarm of agents
 *  generated by the AgentCore class and which evolves through a consensus based completely distributed algorithm.
 *  Each agent has no physical model (at the moment), but it is identified by a tf frame reference in the 2D space
 *  which is oriented with the x axis on the forward direction (z up and y accordingly to a right-handed frame).
 *  Actually z always equals 0, like roll and pitch of the pose of the frame (only x, y and yaw are used in 2D).
 *  Toghether with the frames, also some markers are displayed: those which display the formation statistics on which
 *  the consensus is based (i.e. oriented ellipses in the 2D space) and those relative to the control of the target
 *  statistics (i.e target ellipse) which are 3 interactive markers (actually no external controller like a joystick
 *  can be used to control the target) that can be moved by the user on rviz with a mouse. The formation statistics
 *  represented by the ellipses can be relative to the esitmate of an agent (blue), the common target (orange), or even
 *  the effective statistics of the swarm based on the current pose of its real and virtual agents (light grey).
 *  Lastly, the interactive markers let to modify the position and orientation of the center of the target ellipse and
 *  the lengths of its diameters.
 *  There is no need to synchronize this class with the agents TDMA communication protocol, because it uses several
 *  callbacks on the data produced by the single agent (i.e. it is most AgentCore driven, except for the control of
 *  the target statistics, for which this class is the master).
 *
 *  For more info on this class usage, check the README.md in the package folder.
 *
 *  If you edit this class, please try to follow these C++ style guidelines: http://wiki.ros.org/CppStyleGuide.
 *
 *  ROS params:
 *    + sample_time
 *    + number_of_agents
 *    + verbosity_level
 *    + topic_queue_length
 *    + shared_stats_topic
 *    + target_stats_topic
 *    + agent_poses_topic
 *    + marker_topic
 *    + frame_map
 *    + frame_agent_prefix
 *    + frame_effective_prefix
 *    + frame_ellipse_suffix
 *    + frame_virtual_suffix
 *    + frame_ground_station
 *    + frame_target_ellipse
 *    + marker_dist_min
 *    + marker_dist_max
 *    + marker_steer_min
 *    + marker_steer_max
 *    + target_statistics
 *    + target_from_physics
 */
class VisualizationCore {
 public:
  /*  The constructor retrieves some settings parameters from ROS params if specified by the user (default values
   *  otherwise), initializes all the target statistics with values provided by the user (e.g. using the default 
   *  configuration file, visualization_initialization.yaml) and the publishers and subscribers needed. Lastly, it
   *  initializes also 3 interacrive markers, which are used in rviz to move the target statistics in the 2D space.
   *
   *  Other methods called:
   *    + interactiveMarkerInitialization
   *    + statsVectorPhysicsToMsg
   *    + statsVectorToMsg
   *    + updateTarget
   */
  VisualizationCore();
  ~VisualizationCore();

 private:
  ros::NodeHandle node_handle_;
  ros::NodeHandle *private_node_handle_;
  ros::Publisher target_stats_publisher_;
  ros::Publisher marker_publisher_;
  ros::Subscriber stats_subscriber_;
  ros::Subscriber agent_poses_subscriber_;
  ros::Timer algorithm_timer_;
  tf::TransformListener tf_listener_;
  tf::TransformBroadcaster tf_broadcaster_;
  interactive_markers::InteractiveMarkerServer *interactive_marker_server_;

  double sample_time_;
  int number_of_agents_;
  int verbosity_level_;

  geometry_msgs::Pose target_pose_;
  double target_a_x_;
  double target_a_y_;

  int topic_queue_length_;
  std::string shared_stats_topic_name_;
  std::string target_stats_topic_name_;
  std::string agent_poses_topic_name_;
  std::string marker_topic_name_;
  std::string sync_service_name_;

  std::string frame_map_;
  std::string frame_agent_prefix_;
  std::string frame_effective_prefix_;
  std::string frame_ellipse_suffix_;
  std::string frame_virtual_suffix_;
  std::string frame_ground_station_;
  std::string frame_target_ellipse_;

  formation_control::FormationStatisticsStamped target_statistics_;
  std::vector<formation_control::FormationStatisticsStamped> shared_statistics_grouped_;
  std::vector<int> connected_agents_;

  double marker_dist_min_;
  double marker_dist_max_;
  double marker_steer_min_;
  double marker_steer_max_;


  /*  Broadcasts the given agent pose to the tf with the proper frame name (agent id dependent).
   *
   *  Parameters:
   *    + pose: pose of the agent (paired with a header and its id).
   */
  void agentPosesCallback(const geometry_msgs::PoseStamped &pose);

  /*  All the stuff of this ROS node are handled by several asynchronous callbacks. Every sample time it is only
   *  necessary to compute the effective ellipses: these are based on the current pose of the agents (which are
   *  known globally only by an external node like this one). The aim is to show that the effective ellipse of real
   *  and virtual agents are close to their estimation, and eventually also to the target ellipse (on convergence).
   *
   *  Parameters:
   *    + timer_event: ROS structure which stores the timer info (not used in this case).
   *  Other methods called:
   *    + computeEffectiveEllipse
   */
  void algorithmCallback(const ros::TimerEvent &timer_event);

  /*  Computes the "generalized diameter" starting from the given real diameter of the ellipse.
   *
   *  Parameters:
   *    + diameter: represents one of the two diameters of the ellipse.
   *  Return value:
   *    + the so called "generalized diameter".
   */
  double computeA(const double &diameter) const;

  /*  Computes the real diameter of the ellipse starting from the given "generalized diameter".
   *
   *  Parameters:
   *    + a: the so called "generalized diameter" (it is proportional to the real diameter).
   *  Return value:
   *    + diameter of the ellipse.
   */
  double computeDiameter(const double &a) const;

  /*  Retrieves all the current poses of real or virtual agents (depending on the given parameter) from tf, computes
   *  their current (and effective) formation statistics and updates the proper (effective) spanning ellipse.
   *  The word "effective" is used to distinguish the real formation statistics from the agent estimates.
   *
   *  Parameters:
   *    + frame_suffix: distinguishes between real and virtual effective ellipses.
   *  Other methods called:
   *    + computeStatsFromPoses
   *    + updateSpanningEllipse
   */
  void computeEffectiveEllipse(const std::string &frame_suffix);

  /*  Computes the formation statistics (momentums of first and second order) of a given group of agents.
   *
   *  Parameters:
   *    + poses: vector containing the pose of all the agents (or virtual agents).
   *  Return value:
   *    + effective statistics of the given formation (real or virtual agents).
   */
  formation_control::FormationStatistics computeStatsFromPoses(const std::vector<geometry_msgs::Pose> &poses) const;

  /*  Displays a message with a specific log level, using the proper ROS MACRO. This method is used by all the others
   *  to show errors, warnings and useful info about the state of the node in a homogeneous format; it provides also
   *  five distinct verbosity levels for debug info (e.g. to investigate specific variables and the flow of the code).
   *
   *  Parameters:
   *    + caller_name: name of the method which calls this one;
   *    + message: stream to be sent to the console;
   *    + log_level: integer in range [-3, 5] respectively from fatal to very verbose debug messages.
   */
  void console(const std::string &caller_name, std::stringstream &message, const int &log_level) const;

  /*  When an interactive marker is moved in rviz, this callback is called. It updates the target ellipse accordingly
   *  to which marker has been moved: the two diameters can be just stretched, while the pose has a sort of dynamics
   *  to avoid too fast changes (especially in its orientation). This callback also guarantees that the interactive
   *  markers stay attached to the target ellipse in their fixed relative position.
   *
   *  Parameters:
   *    + feedback: interactive marker feedback structure which stores all its info (current pose, ...).
   *  Other methods called:
   *    + computeA
   *    + interactiveMarkerGuidance
   *    + physicsToStats
   *    + updateTarget
   */
  void interactiveMarkerCallback(const visualization_msgs::InteractiveMarkerFeedbackConstPtr &feedback);

  /*  Avoids too fast changes in position and orientation of the target ellipse when it is moved through the
   *  interactive markers in rviz: it can be thought as "a sort of inertia" of the ellipse.
   *
   *  Parameters:
   *    + target: current pose of the interactive marker that has been moved in rviz (target pose without saturation).
   *    + current: current pose of the target ellipse.
   *  Other methods called:
   *    + saturation
   */
  void interactiveMarkerGuidance(const geometry_msgs::Pose &target, geometry_msgs::Pose &current);

  /*  Initializes the 3 interactive markers: one in the center of the ellipse to change its 2D pose and the others on
   *  its border to change its diameters.
   *
   *  Other methods called:
   *    + computeDiameter
   *    + makeInteractiveMarkerAxis
   *    + makeInteractiveMarkerPose
   *    + saturation
   *    + statsToPhysics
   */
  void interactiveMarkerInitialization();

  /*  Builds a simple gray cube (visualization_msgs::Marker::CUBE) on rviz with the given scale factor.
   *
   *  Parameters:
   *    + scale: scale factor for x, y and z axis.
   *  Return value:
   *    + the marker structure.
   */
  visualization_msgs::Marker makeBox(const double &scale) const;

  /*  Adds a simple gray cube to the given interactive marker controls.
   *
   *  Parameters:
   *    + interactive_marker: interactive marker structure passed by reference (i.e. used by the caller).
   *  Other methods called:
   *    + makeBox
   */
  void makeBoxControl(visualization_msgs::InteractiveMarker &interactive_marker) const;

  /*  Builds an ellipse (visualization_msgs::Marker::CYLINDER with small height) with the given diameters and colored
   *  on the base of the frame value ("agent_stats" : blue, "target_stats" : orange, "effective_stats" : gray).
   *
   *  Parameters:
   *    + diameter_x: x diameter of the ellipse.
   *    + diameter_y: y diameter of the ellipse .
   *    + frame: string to select the proper color.
   *    + id: to distinguish between agents (each one has its own ellipse of it estimate statistics).
   *  Return value:
   *    + the marker structure.
   */
  visualization_msgs::Marker makeEllipse(const double &diameter_x, const double &diameter_y, const std::string &frame,
                                         const int &id) const;

  /*  Creates a single axis translating interactive marker with the given pose (used on rviz).
   *
   *  Parameters:
   *    + pose: pose of the interactive marker (it will be on the border of the target ellipse, but they are not linked).
   *    + axis: specifies the axis of the marker and it is either "x" or "y".
   *  Other methods called:
   *    + makeBoxControl
   */
  void makeInteractiveMarkerAxis(const geometry_msgs::Pose &pose, const std::string &axis);

  /*  Creates a 2D translating (x and y) and rotating (z) interactive marker with the given pose (used on rviz).
   *
   *  Parameters:
   *    + pose: pose of the interactive marker (it will be on the center of the target ellipse, but they are not linked).
   *  Other methods called:
   *    + makeBoxControl
   */
  void makeInteractiveMarkerPose(const geometry_msgs::Pose &pose);

  /*  Computes the statistics from the ellipse described by its geometric variables: the 2D pose of its center and the
   *  length of its diameters (a_x and a_y are not properly the diameters, let's call them "generalized diameters").
   *
   *  Parameters:
   *    + pose: 2D pose of the center of the ellipse representing the given statistics.
   *    + a_x: "generalized diameter" of the ellipse.
   *    + a_y: "generalized diameter" of the ellipse.
   *  Return value:
   *    + it is either the target statistics or an agent current estimate statistics.
   */
  formation_control::FormationStatistics physicsToStats(const geometry_msgs::Pose &pose, const double &a_x,
                                                        const double &a_y) const;

  /*  Computes the saturation of the given value w.r.t. the provided thresholds.
   *
   *  Parameters:
   *    + value: value to be processed;
   *    + min: lower bound threshold;
   *    + max: upper bound threshold.
   *  Return value:
   *    + saturated value.
   */
  double saturation(const double &value, const double &min, const double &max) const;

  /*  Updates the spanning ellipse of a specific agent from its current estimate statistics received from the shared
   *  topic. If it is the first statistics received from a certain agent, it also broadcasts the target statistics to
   *  all the agents to let the new one knows it.
   *
   *  Parameters:
   *    + shared: an agent current estimate statistics with header and id.
   *  Other methods called:
   *    + updateSpanningEllipse
   *    + updateTarget
   */
  void sharedStatsCallback(const formation_control::FormationStatisticsStamped &shared);

  /*  Computes the 2D pose of the center of the ellipse from the given statistics vector and fills the "generalized
   *  diameters" (a_x and a_y) which are passed by reference to this method.
   *
   *  Parameters:
   *    + stats: an agent current estimate statistics (target statistics are handled with the other method).
   *    + a_x: "generalized diameter" of the ellipse passed by reference (i.e. used by the caller).
   *    + a_y: "generalized diameter" of the ellipse passed by reference (i.e. used by the caller).
   *  Other methods called:
   *    + statsToPhysics
   *  Return value:
   *    + 2D pose of the center of the ellipse representing the given statistics.
   */
  tf::Pose statsToPhysics(const formation_control::FormationStatistics &stats, double &a_x, double &a_y);

  /*  Computes the 2D pose of the center of the ellipse from the given statistics vector and fills the "generalized
   *  diameters" (a_x and a_y) which are passed by reference to this method. Only in the case of target statistics, a
   *  correction on the yaw term of the pose is necessary to ensure that the angle belongs to [-pi,pi] to avoid an
   *  annoing discontinuity of the pose of the interactive markers "attached" to the target ellipse.
   *
   *  Parameters:
   *    + stats: it is either the target statistics or an agent current estimate statistics.
   *    + a_x: "generalized diameter" of the ellipse passed by reference (i.e. used by the caller).
   *    + a_y: "generalized diameter" of the ellipse passed by reference (i.e. used by the caller).
   *    + theta_old: represent the previous orientation of the target ellipse (it must be nan otherwise).
   *  Other methods called:
   *    + thetaCorrection
   *  Return value:
   *    + 2D pose of the center of the ellipse representing the given statistics.
   */
  tf::Pose statsToPhysics(const formation_control::FormationStatistics &stats, double &a_x, double &a_y,
                          const double &theta_old);

  /*  Convetrs statistics from std::vector<double> ellipse geometry data vector to
   *  formation_control::FormationStatistics ROS message.
   *
   *  Parameters:
   *    + vector: data is stored in the following order (x, y, theta, ax, ay).
   *  Other methods called:
   *    + computeA
   *    + physicsToStats
   *  Return value:
   *    + message filled with the given values.
   */
  formation_control::FormationStatistics statsVectorPhysicsToMsg(const std::vector<double> &vector) const;

  /*  Convetrs statistics from std::vector<double> first and second order momentum data vector to
   *  formation_control::FormationStatistics ROS message.
   *
   *  Parameters:
   *    + vector: data is stored in the following order (mx, my, mxx, mxy, myy).
   *  Return value:
   *    + message filled with the given values.
   */
  formation_control::FormationStatistics statsVectorToMsg(const std::vector<double> &vector) const;

  /*  Updates the orientation of the target ellipse to avoid an annoing discontinuity of the pose of the interactive
   *  markers which are "attached" to it. To do so, it evaluates the closest configuration to the previous orientation
   *  handling the discontinuity on pi/2 and -pi/2 and converting the angle to the range [-pi, pi].
   *
   *  Parameters:
   *    + theta: the current orientation of the target ellipse passed by reference (i.e. used by the caller).
   *    + theta_old: the previous orientation of the target ellipse.
   */
  void thetaCorrection(double &theta, const double &theta_old) const;

  /*  Updates the ellipse marker shown in rviz of the given statistics, which can be either the target statistics
   *  (depicted in orange) or an agent current estimate statistics (depicted in blu). An ellipse can be represented
   *  by the pose of its center and the length of its diameters, and thanks to its simmetry the rotation can belong
   *  to [-pi/2, pi/2] (and this is how an ellipse marker is encoded in rviz). However, in the case of the target
   *  statistics, a correction on the yaw term of the pose is necessary to ensure that the angle belongs to [-pi,pi]
   *  to avoid an annoing discontinuity of the pose of the interactive markers "attached" to the target ellipse.
   *
   *  Parameters:
   *    + msg: it is either the target statistics or an agent current estimate statistics.
   *  Other methods called:
   *    + computeDiameter
   *    + makeEllipse
   *    + statsToPhysics
   */
  void updateSpanningEllipse(const formation_control::FormationStatisticsStamped &msg);

  /*  Updates the target statistics with the new given one and updates also its ellipse in rviz.
   *
   *  Parameters:
   *    + target: new target statistics to be published.
   *  Other methods called:
   *    + updateSpanningEllipse
   *    + updateTargetStats
   */
  void updateTarget(const formation_control::FormationStatistics &target);

  /*  Publishes the given target statistics in the proper (predefined) topic. It has the effect to provide to all the
   *  agents (which are subscribed to this topic) the new target statistics.
   *
   *  Parameters:
   *    + target: new target statistics to be published.
   */
  void updateTargetStats(const formation_control::FormationStatistics &target);
};

#endif
